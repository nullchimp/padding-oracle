from multiprocessing import Process, Queue, Manager

def read_queue(q, plaintext):
    while True:
        idx, data = q.get()
        plaintext[idx] = data

        br = True
        for pt in plaintext:
            if pt == b'':
                br = False
                break

        if br:
            break


def extract_blocks(cipher, block_size=16):
    cipher_range = len(cipher) // block_size
    return [cipher[i*block_size:(i+1)*block_size] for i in range(cipher_range)]


def find_blocks(q, process_index, blocks, validate_func):
    block_size = len(blocks[0])
    plaintext_block = bytearray([0 for _ in range(block_size)])

    for i in range(block_size):
        idx = block_size - i - 1

        padding = bytearray([0 for _ in range(idx + 1)] + [(i + 1) for _ in range(i)])
        prime_block = [a ^ b ^ c for a, b, c, in zip(plaintext_block, blocks[0], padding)]

        next_byte = prime_block[idx]+1
        for byte in list(range(next_byte, 256)) + list(range(0, next_byte)):
            prime_block[idx] = byte

            testing_cipher = bytes(prime_block) + blocks[1]
            if validate_func(testing_cipher):
                plaintext_block[idx] = byte ^ blocks[0][idx] ^ (i + 1)
                #print(bytes([b for b in plaintext_block if b > block_size]))
                break

    q.put((process_index, bytes([b for b in plaintext_block])))


def find_plaintext(cipher_text, validate_func):
    with Manager() as manager:
        blocks = extract_blocks(cipher_text)
        plaintext_blocks = manager.list([b'' for _ in range(len(blocks) - 1)])

        q = Queue()
        p = Process(target=read_queue, args=(q, plaintext_blocks))
        p.start()

        processes = [p]

        for i in range(len(blocks)-1):
            p = Process(target=find_blocks, args=(q, i, blocks[i:(i+2)], validate_func))
            p.start()

            processes.append(p)

        for p in processes:
            p.join()

        return b''.join([pt for pt in plaintext_blocks])

def change_cipher(cipher_text, plain_text, wanted_plaintext, validate_func, block_size=16):
    for block in range((len(plain_text)//block_size)-1, -1, -1):
        for i in range(block_size):
            idx = (block*block_size) +i
            xor_byte = plain_text[idx] ^ wanted_plaintext[idx]

            cipher_text[idx] ^= xor_byte

        p = find_plaintext(bytes(cipher_text), validate_func)

        # print(b'Temporary Plaintext: ', p)
        if block > 0:
                p1 = plain_text[(block - 1) * block_size:block * block_size]
                p2 = (p[(block-1)*block_size:block*block_size])
                for i in range(block_size):
                        cipher_text[((block-1)*block_size) +i] ^= (p2[i] ^ p1[i])

    return bytes(cipher_text)

